#' Plot reference signature and comparison signature based on the results of CMPS algorithm
#' 
#' This function aligns two signatures and shows which basis segments find the congruent 
#' registration position.
#'
#' @param cmps.result a list generated by `extract_feature_cmps(..., include = "full_result")`. Note 
#' that `include = "full_result"` is required in order for the `cmps.result` to be used in this function
#'
#' @return a list
#' * `segment_shift_plot`: a plot object generated by ggplot2. In this plot only basis segments that are 
#' congruent matching profile segments (CMPS) are plotted along with the comparison profile; each basis 
#' segment are shifted to the position where it obtains either a consistent correlation peak or a 
#' cross-correlation peak closest to the congruent registration position
#' * `` 
#'     + `CMPS.score`: computed CMPS score
#'     + `rec.position`: the recommended position that results in the CMPS score
#'     + `pos.df`: a dataframe that includes all positions and their corresponding CMPS score 
#'     + `nseg`: the number of basis segments obtained from the reference profile
#' 
#' @export
#' @importFrom assertthat assert_that
#'
#' @examples
#' library(bulletxtrctr)
#' library(tidyverse)
#' library(x3ptools)
#' library(CMPS)
#' 
#' data("bullets")
#' land2_3 <- bullets$sigs[bullets$bulletland == "2-3"][[1]]
#' land1_2 <- bullets$sigs[bullets$bulletland == "1-2"][[1]]
#' 
#' # compute cmps
#' 
#' # algorithm with multi-peak insepction at three different segment scales
#' cmps_with_multi_scale <- extract_feature_cmps(land2_3$sig, land1_2$sig, include = "full_result" )
#' 
#' # algorithm with multi-peak inspection at the basis scale only
#' cmps_without_multi_scale <- extract_feature_cmps(land2_3$sig, land1_2$sig, 
#'                                                  npeaks.set = 5, include = "full_result" )
#' \dontrun{
#' library(tidyverse)
#' library(bulletxtrctr)
#' 
#' lands <- unique(bullets$bulletland)
#' 
#' comparisons <- data.frame(expand.grid(land1 = lands[1:6], land2 = lands[7:12]), 
#'                           stringsAsFactors = FALSE)
#' 
#' comparisons <- comparisons %>% mutate(
#'   aligned = purrr::map2(.x = land1, .y = land2, 
#'                         .f = function(xx, yy) {
#'                           land1 <- bullets$sigs[bullets$bulletland == xx][[1]]
#'                           land2 <- bullets$sigs[bullets$bulletland == yy][[1]]
#'                           land1$bullet <- "first-land"
#'                           land2$bullet <- "second-land"
#'                           
#'                           sig_align(land1$sig, land2$sig)
#'                         }))
#' 
#' comparisons <- comparisons %>% 
#'   mutate(cmps = aligned %>% purrr::map(.f = function(a) {
#'     extract_feature_cmps(a$lands$sig1, a$lands$sig2, include = "nseg")
#'   }))
#' 
#' # comparisons.cmps <- comparisons %>% 
#' #   mutate(cmps = aligned %>% purrr::map_dbl(.f = function(a) {
#' #     extract_feature_cmps(a$lands$sig1, a$lands$sig2, include = NULL)
#' #   }))
#' # comparisons.cmps %>% select(land1, land2, cmps) 
#' 
#' comparisons <- comparisons %>% 
#'   mutate(
#'     cmps_score = sapply(comparisons$cmps, function(x) x$CMPS.score),
#'     cmps_nseg = sapply(comparisons$cmps, function(x) x$nseg)
#'   )
#' 
#' cp1 <- comparisons %>% select(land1, land2, cmps_score, cmps_nseg)
#' cp1
#' }
#' @references 
#' Chen, Zhe, Wei Chu, Johannes A Soons, Robert M Thompson, John Song, 
#' and Xuezeng Zhao. 2019. “Fired Bullet Signature Correlation Using the 
#' Congruent Matching Profile Segments (CMPS) Method.” Forensic Science 
#' International, December, #109964. https://doi.org/10.1016/j.forsciint.2019.109964.

cmps_signature_plot <- function(cmps.result) {
  # type = c("segment", "signature")
  
  # todo: check if cmps.result has all necessary names
  
  sig1 <- cmps.result$parameters$x
  sig2 <- cmps.result$parameters$y
  
  congruent.seg <- cmps.result$congruent.seg
  congruent.pos <- cmps.result$congruent.pos
  
  # get the segments
  segs <- cmps.result$segments
  
  # create a group for each segment
  gp <- lapply(names(segs$segs[congruent.seg]), function(nn){
    return(rep(nn, length(segs$segs[congruent.seg][[nn]])))
  }) %>% unlist() 
  
  # generate df for plotting    
  
  # type <- match.arg(type)
  
  # find shift for each segment
  seg.pos <- sapply(cmps.result$ccp.list[congruent.seg], function(ccp.list.element, Tx, con.pos) {
    # pp <- abs(ccp.list.element - con.pos) <= Tx
    
    pp <- which.min(abs(ccp.list.element - con.pos))
    
    if(abs(ccp.list.element[pp] - con.pos) > Tx) {
      stop("something wrong with seg.pos")
    }
    
    ccp.list.element[pp]
    
  }, cmps.result$parameters$Tx, congruent.pos)
  
  
  names(seg.pos) <- names(segs$index[congruent.seg])
  
  
  # cat(names(seg.pos))
  
  # repeat the shifts many times to prepare for a data.frame used for plotting
  seg_shift <- lapply(names(segs$segs[congruent.seg]), function(nn){
    return(rep(seg.pos[nn], length(segs$segs[congruent.seg][[nn]])))
  }) %>% unlist()
  
  # for the signature level, use the median of 
  # all segment shifts as the signature shift
  # browser()
  
  sig_shift <- median(seg.pos)
  
  # data frame for segment shifts
  plot.df.seg_shift <- data.frame(x=segs$index[congruent.seg] %>% unlist() + seg_shift,
                                  sig=segs$segs[congruent.seg] %>% unlist(),
                                  gp = gp)
  
  # data frame for signature shift
  plot.df.sig_shift <- data.frame(x=segs$index[congruent.seg] %>% unlist() + sig_shift,
                                  sig=segs$segs[congruent.seg] %>% unlist(),
                                  gp = gp)
  
  # data frame for plotting comparison profile
  plot.df.comp <- data.frame(x=1:length(sig2), sig = sig2, gp = 0)
  
  # data frame for plotting reference profile
  plot.df.ref <- data.frame(x=1:length(sig1) + sig_shift, sig=sig1, gp=0)
  
  # segment shifts plot
  p1 <- plot.df.seg_shift %>% ggplot(aes(x=x, y=sig, group = gp)) +
    geom_line(color = "red", size = 1.2) +
    geom_line(data = plot.df.comp, color = "darkgreen") + 
    theme_bw()
  
  # signature shift plot
  p2 <- plot.df.sig_shift %>% ggplot(aes(x=x, y=sig, group = gp)) +
    geom_line(color = "red", size = 1.2) +
    geom_line(data = plot.df.comp, color = "darkgreen") + 
    geom_line(data = plot.df.ref, color = "red", linetype = "longdash") + 
    theme_bw()
  
  return(list(
    segment_shift_plot = p1, signature_shift_plot = p2,
    seg_shift = seg_shift, sig_shift = sig_shift,
    seg.pos = data.frame(seg.idx = names(seg.pos), seg.shift = seg.pos)))
  
}


cmps_segment_plot <- function(cmps.result, seg.idx = 1){
  
  # obtain results from cmps.result
  segments <- cmps.result$segments
  npeaks.set <- cmps.result$parameters$npeaks.set
  seg_scale_max <- length(npeaks.set)
  
  # compute the cross-correlation for each segment scale
  ccr.list <- lapply(1:seg_scale_max, function(seg_scale) {
    
    get_ccr_peaks(cmps.result$parameters$y, segments, seg_scale = seg_scale, 
                  nseg = seg.idx, npeaks = cmps.result$parameters$npeaks.set[seg_scale])
    
    
  })
  
  # compute segments in different scales
  seg.scale.list <- lapply(1:seg_scale_max, function(seg_scale) {
    
    get_seg_scale(segments, seg.idx, seg_scale)
    
  })
  
  # data frame for plotting the comparison profile
  plot.df.comp <- data.frame(
    x=1:length(cmps.result$parameters$y), 
    sig = cmps.result$parameters$y, 
    gp = 0
  )
  
  # a list of plots
  pp.list <- lapply(1:seg_scale_max, function(scale.idx) {
    
    # plot the selected segment in all positions where
    # it obtains cross-correlation peaks
    p1 <- seg.scale.list[[scale.idx]] %>% as.data.frame() %>% 
      ggplot() +
      geom_line(aes(x=aug_idx, y=aug_seg), color="black", size=1) + 
      geom_line(data=plot.df.comp, aes(x=x, y=sig), color="darkgreen") +
      xlab("Position") + 
      ylab("Profile Height") + 
      ggtitle(paste("Plotting for scale", scale.idx, "of segment", seg.idx)) + 
      theme_bw()
    
    p.df <- lapply(length(ccr.list[[scale.idx]]$peaks.pos):1, function(i) {
      data.frame(x = seg.scale.list[[scale.idx]]$aug_idx + ccr.list[[scale.idx]]$peaks.pos[i],
                 y = seg.scale.list[[scale.idx]]$aug_seg,
                 color = i)
    }) %>% do.call(rbind, .)
    
    p1 <- p1 +
      geom_line(data = p.df,
                aes(x=x, y=y, color = color, group = color),
                size = 1, alpha = 1, show.legend = FALSE, linetype = "dashed")
    
    
    if(length(ccr.list[[scale.idx]]$peaks.pos) == 1) {
      p1 <- p1 + scale_color_gradient(low="red", high="red")
    } else {
      p1 <- p1 + scale_color_gradient(low="red", high="blue") 
    }
    
    
    # browser()
    
    # plot the cross-correlation curve with peaks highlighted
    p2 <- data.frame(x=ccr.list[[scale.idx]]$adj.pos, ccf=ccr.list[[scale.idx]]$ccr$ccf) %>% 
      ggplot(aes(x=x, y=ccf))+
      geom_line() + 
      geom_point(
        data = data.frame(
          x = ccr.list[[scale.idx]]$peaks.pos, 
          ccf = ccr.list[[scale.idx]]$peaks.heights,
          size = seq(2, 1.2, length.out = length(ccr.list[[scale.idx]]$peaks.pos))
        ),
        aes(colour=size), show.legend = FALSE
      ) +
      xlim(min(ccr.list[[1]]$adj.pos), max(ccr.list[[1]]$adj.pos)) +
      geom_vline(xintercept = cmps.result$congruent.pos,
                 color = "red", linetype = "longdash") +
      scale_color_gradient(low="blue", high="red") + 
      xlab("Shift Position") + 
      ylab("Correlation Coefficient") + 
      ggtitle(paste("Plotting for scale", scale.idx, "of segment", seg.idx)) +
      theme_bw()
    
    if(length(cmps.result$parameters$npeaks.set) > 1) {
      p2 <- p2 +
        geom_vline(xintercept = ccr.list[[seg_scale_max]]$peaks.pos,
                   color = "darkgreen", linetype = "twodash") + 
        geom_vline(xintercept = c(ccr.list[[seg_scale_max]]$peaks.pos - cmps.result$parameters$Tx,
                                  ccr.list[[seg_scale_max]]$peaks.pos + cmps.result$parameters$Tx),
                   color = "blue", linetype = "dashed")
    }
    
    
    return(list(segment_plot = p1, scale_ccf_plot = p2))
    
  })
  
  return(pp.list)
}





























